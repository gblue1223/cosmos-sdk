# 튜토리얼: Cosmos-SDK 애플리케이션을 코딩하는 방법

이 튜토리얼에서는 Cosmos-SDK를 사용하여 애플리케이션을 코딩하는 기본 사항을 학습합니다. 텐더민트 (Tendermint)와 코스모스 생태계 (Cosmos Ecosystem)에 대한 소개부터 시작하여 텐더 민트 (Tendermint) 소프트웨어와 Cosmos-SDK 프레임워크에 대한 개괄적인 개요를 살펴 보겠습니다. 그 다음에는 코드에 대해 알아보고 Cosmos-SDK 제일 윗단에서 간단한 애플리케이션을 작성하는 방법을 안내합니다.

## 텐더민트와 코스모스

블록 체인은 세 가지 개념적 레이어로 나눌 수 있습니다:

- **네트워킹:** 트랜잭션 전파에 책임이 있습니다.
- **합의:** 다음 트랜잭션 집합의 처리에 동의하기 위해 검증인 노드들을 활성화 합니다 (예: 블록체인에 트랜잭션 블록 추가).
- **응용 프로그램:** 트랜잭션 집합에 주어진 상태를 업데이트하는 작업을 담당합니다. 즉, 트랜잭션을 처리합니다.

*네트워킹* 계층은 각 노드가 트랜잭션을 수신 하는지 확인합니다. *합의* 계층은 각 노드가 자신의 로컬 상태를 수정하기 위해 동일한 트랜잭션에 동의하는지 확인합니다. *응용 프로그램* 레이어는 트랜잭션을 처리합니다. 트랜잭션과 상태가 주어지면 응용 프로그램은 새로운 상태를 반환합니다. Bitcoin을 예를 들면, 응용 프로그램 상태는 각 계정에 대한 원장 또는 잔액 목록입니다 (실제로는 UTXO의 목록으로 Unspent Transaction Output의 약자이지만 단순화를 위해 잔액이라고합시다). 그리고 트랜잭션은 이러한 잔액 목록을 변경하여 응용 프로그램의 상태를 수정합니다. Ethereum의 경우 애플리케이션은 가상 머신입니다. 각 트랜잭션은 이 가상 머신을 통해 진행되며 응용 프로그램의 상태가 트랜잭션 내부에서 호출된 스마트 계약에 따라 수정됩니다. 

텐더민트 이전에는, 블록 체인을 만들려면 세 개의 레이어를 처음부터 모두 만들어야했습니다. 대부분의 개발자가 Bitcoin 코드베이스를 포크하거나 복제하는 것을 선호했지만 Bitcoin의 프로토콜의 한계에 의해 제약을받기 때문에 실증나는 작업이었습니다. Ethereum Virtual Machine (EVM)은 이 문제를 해결하고 스마트 계약을 통해 사용자 정의 가능한 논리를 실행할 수 있게 하여 분산된 응용 프로그램 개발을 단순화하도록 설계되었습니다. 그러나 블록 체인 자체의 한계 (상호 운용성, 확장 성 및 사용자 정의)를 해결하지 못했습니다. Go-Ethereum은 Bitcoin의 코드베이스처럼 하드 포크하기가 어려운 매우 획일적인 기술 스택입니다. 

Tendermint는 이러한 문제를 해결하고 개발자에게 대안을 제공하기 위해 고안되었습니다. Tendermint의 목표는 빌드 하려는 모든 응용 프로그램 개발자를 지원하는 일반 엔진으로서 블록 체인의 *네트워킹* 및 *합의* 레이어를 제공하는 것입니다. Tendermint를 사용하면 개발자는 *응용 프로그램* 레이어에만 집중해야하므로 수백시간의 작업시간과 값 비싼 개발 환경을 절약 할 수 있습니다. 참고로 Tendermint는 Tendermint Core 엔진 내에서 사용 되는 비잔틴 장애 허용 합의 알고리즘을 나타냅니다.

Tendermint는, [ABCI] (https://github.com/tendermint/abci)(Application-BlockChain Interface) 라 불리는 소켓 프로토콜을 통해 블록체인 엔진인 Tendermint Core (*네트워킹* 및 *합의* 레이어)를 *응용 프로그램* 레이어에 연결합니다. 개발자는 Tendermint Core 엔진에서 실행되는 ABCI 지원 응용 프로그램을 작성하기 위해 몇 가지 메시지만 구현 하면 됩니다. ABCI는 언어에 구속력이 없습니다. 즉, 개발자는 어떤 프로그래밍 언어를 이용해서 블록 체인의 *응용 프로그램* 파트를 구현할 수 있습니다. Tendermint Core 엔진 위에 구축하면 다음과 같은 이점도 있습니다.

- ** 공용 또는 사설 블록 체인이 가능합니다.** 개발자는 Tendermint Core 위에 권한이 부여 된 (사설) 권한이 없는 (공용) 모든 블록 체인 응용 프로그램을 배포 할 수 있습니다. 
-** 성능.** 텐더 민트 코어는 짧은 시간 간격으로 많은 수의 트랜잭션을 처리 할 수있는 최첨단 블록 체인 컨센서스 엔진입니다. Tendermint Core의 블록 시간은 1 초 정도로 낮을 수 있으며 해당 기간에 수천 회의 트랜잭션을 처리 할 수 ​​있습니다.
- ** 즉각적인 완결성.** Tendermint 컨센서스 알고리즘의 속성은 즉각적인 완결성입니다. 즉 유효성 검사기의 1/3 미만이 악성 코드 (비잔틴) 인 한 포크는 생성되지 않습니다. 사용자는 블록이 생성되는 즉시 트랜잭션이 완결되었는지 확인할 수 있습니다.
-**보안.** Tendermint Core의 합의는 단지 장애를 허용하는 것이 아니라, 책임감있는 최적의 비잔틴 장애 허용 (BFT) 에 있습니다. 만일 블록 체인이 포크되면, 책임을 밝힐 수있는 방법이 있습니다.
- **라이트 클라이언트 지원**. 텐더민트는 내장된 라이트 클라이언트를 제공합니다.

하지만 가장 중요한 점은 텐더민트는 [Inter-Blockchain Communication Protocol] (https://github.com/cosmos/cosmos-sdk/tree/develop/docs/spec/ibc) (IBC)과 호환된다는 것입니다. 즉, 공용이든 사설이든 텐더민트 기반 블록 체인은 본질적으로 코스모스 생태계와 연결되어 생태계의 다른 블록 체인과 토큰을 안전하게 교환 할 수 있습니다. IBC와 코스모스를 통한 상호 운용성의 혜택은 텐더민트 체인의 자주권을 보호합니다. 비 텐더민트 체인은 IBC 어댑터 또는 페그존을 통해 코스모스에 연결할 수도 있지만 이 내용은 이 문서의 범위를 벗어납니다.

코스모스 생태계에 대한 자세한 내용은 [이 글] (https://blog.cosmos.network/understanding-the-value-proposition-of-cosmos-ecaef63350d)을 참조하십시오.


## 코스모스SDK 소개

텐더민트 기반 블록 체인을 개발한다는 것은 애플리케이션 (즉, 상태 머신) 만 코딩 하면 된다는 것을 의미합니다. 하지만 그 자체로는 다소 어려울 수 있습니다. 이것이 바로 Cosmos-SDK가 존재하는 이유입니다.

[Cosmos-SDK] (https://github.com/cosmos/cosmos-sdk)는 Cosmos 허브와 같은 다중 자산 Proof-of-Stake (PoS) 블록 체인이자 Proof-Of -Authority (PoA) 블록 체인을 구축하기위한 플랫폼.

Cosmos-SDK의 목표는 개발자가 일반적인 블록 체인 기능을 다시 만들 필요 없이 Cosmos 네트워크 내에서 상호 운용 가능한 맞춤 블록 첸인 응용 프로그램을 쉽게 만들 수있게하고, Tendermint ABCI 응용 프로그램을 작성하는 복잡성을 제거하는 것입니다. 우리는 Tendermint 위에 안전한 블록 체인 어플리케이션을 구축하기 위해 npm과 유사한 프레임워크의 SDK를 구상하고 있습니다.

SDK는 설계 측면에서 유연성과 보안성을 최대한 신경쓰고 있습니다. 프레임워크는 응용 프로그램이 원하는대로 요소를 혼합하고 일치시킬 수있는 모듈 실행 스택 위주로 설계되었습니다. 또한 모든 모듈은 보다 강력한 응용 프로그램 보안을 위해 샌드박스화되어 있습니다.

이것은 두 가지 주요 원칙에 기반합니다:

- ** 합성성:** 누구나 Cosmos-SDK 용 모듈을 만들 수 있으며 이미 구축 된 모듈을 통합하는 것은 블록체인 어플리케이션으로 가져 오는 것 만큼 간단합니다.

- **기능들:** SDK는 기능 기반 보안에서 영감을 얻었으며, 수년간 블록 체인 상태 머신과의 씨름을 통해 영향을 끼쳤습니다. 대부분의 개발자는 자체 모듈을 만들 때 다른 타사 모듈에 액세스 해야합니다. Cosmos-SDK는 개방형 프레임워크이며 이러한 모듈 중 일부는 악의적이라고 가정하기 때문에, 객체 기능 (OCAPS) 기반 원칙을 사용하여 SDK를 설계했습니다. 실제로, 이는 각 모듈이 다른 모듈에 대한 액세스 제어 목록을 유지하는 대신, 각 모듈은 사전 정의 된 기능 세트를 부여하기 위해 다른 모듈에 전달할 수 있는 키퍼라는 특수 객체를 구현한다는 것을 의미합니다. 예를 들어 모듈 A의 키퍼 인스턴스가 모듈 B로 전달되면, 후자는 모듈 A의 제한된 함수 집합을 호출 할 수 있습니다. 각 키퍼의 기능은 모듈 개발자가 정의하며 각 타사 모듈에 전달되는 기능을 기반으로 타사 모듈의 외부 코드 안전성을 이해하고 감사하는 것은 개발자의 임무입니다. '기능'에 대한 더 자세한 내용은 [이 글](http://habitatchronicles.com/2017/05/what-are-capabilities/)을 참조하십시오.

*참고: 현재 Cosmos-SDK는 Golang에만 존재합니다. 즉, 개발자는 Golang으로만 SDK 모듈을 개발할 수 있습니다. 앞으로, SDK는 다른 프로그래밍 언어로 구현 될 것이라 기대됩니다. Tendermint 팀에서 자금을 지원하는 것이 결국에는 가능할 것입니다.*

## Tendermint 및 ABCI에 대한 알림

Cosmos-SDK는 블록 체인의 *응용 프로그램* 레이어를 개발하기위한 프레임워크입니다. 이 응용 프로그램은 [Application-Blockchain Interface] (https://github.com/tendermint/abci)의 약자 인 ABCI라는 간단한 프로토콜을 지원하는 모든 합의 엔진 (*합의* + *네트워킹* 레이어)에 연결될 수 있습니다.

Tendermint Core는 Cosmos-SDK 위에 구축된 기본 컨센서스 엔진입니다. *응용 프로그램* 및 *합의 엔진* 각자의 책임을 잘 이해하는 것이 중요합니다.

*합의 엔진*의 책임:
- 트랜잭션 전파
- 유효한 트랜잭션의 순서에 대한 동의.

*응용 프로그램*의 책임:
- 트랜잭션 생성
- 트랜잭션이 유효한지 확인.
- 트랜잭션 처리 (상태 변경 포함)

*합의 엔진*은 각 블록에 대해 제공된 유효성 검증인 집합에 대한 지식을 갖고 있지만 유효성 검사기 집합 변경을 발동하는 것은 *응용 프로그램*의 책임이라는 점을 강조 할 가치가 있습니다. 이것이 Cosmos-SDK와 Tendermint를 통해 **공개 체인과 사설 체인**을 모두 구축 할 수 있는 이유입니다. 체인은 유효성 검증인의 설정 변경을 제어하는 ​​응용 프로그램 수준에서 정의 된 규칙에 따라 공개 또는 사설이됩니다.

ABCI는 *합의 엔진*과 *응용 프로그램* 사이의 연결을 설정합니다. 본질적으로, 핵심은 두 가지 메시지입니다:

-`CheckTx`: 트랜잭션이 유효한지 어플리케이션에게 물어 봅니다. 검증인의 노드가 트랜잭션을 받으면 검증인의 노드는 `CheckTx`를 실행합니다. 트랜잭션이 유효하면 메모리풀에 추가됩니다.
-`DeliverTx`: 애플리케이션에게 트랜잭션을 처리하고 상태를 업데이트하도록 요청합니다.

*합의 엔진*과 *응용 프로그램*이 서로 어떻게 상호 작용 하는지에 대한 개괄적인 개요를 설명하겠습니다.

- 항상, 검증인 노드의 합의 엔진 (Tendermint Core)이 트랜잭션을 수신 할 때마다 CheckTx를 통해 응용 프로그램에 전달하여 유효성을 검사합니다. 유효하면 트랜잭션이 메모리풀에 추가됩니다.
- 우리가 블록 N에 있다고합시다. 유효성 검증인 세트 V가 있습니다. 다음 블록의 제안자는 *합의 엔진*에 의해 V에서 선택됩니다. 제안자는 메모리풀에서 유효한 트랜잭션을 수집하여 새 블록을 만듭니다. 그런 다음 블록은 다른 검증인들에게 알려지고 서명/커밋 됩니다. V의 2/3 이상이 *사전커밋*에 서명하면 블록은 블록 N+1이됩니다 (합의 알고리즘에 대한 자세한 설명은 [여기] (https://github.com/tendermint/tendermint/wiki/Byzantine-Consensus-Algorithm)를 클릭하십시오.
- 블록 N+1이 V의 2/3 이상에 의해 서명 될 때, 그것은 full-node로 알려지게 됩니다. full-node가 해당 블록을 수신하면 유효성을 확인합니다. 블록이 V의 2/3 이상 유효한 서명들을 보유하고 블록의 모든 트랜잭션들이 유효한 경우 블록은 유효합니다. *합의 엔진*은 트랜잭션의 유효성을 검사하기 위해 'DeliverTx'를 통해 응용 프로그램으로 전송합니다. 각 트랜잭션 이후에 'DeliverTx`는 트랜잭션이 유효하면 새로운 상태를 반환합니다. 블록이 끝나면 최종 상태가 확약됩니다. 물론, 이것은 블록 내의 트랜잭션 순서가 중요하다는 것을 의미합니다.

## SDK-app의 아키텍처

Cosmos-SDK는 Tendermint 기반 블록 체인 응용 프로그램을 위한 기본 템플릿을 제공합니다. 이 템플릿은 [여기] (https://github.com/cosmos/cosmos-sdk)에서 찾을 수 있습니다.

본질적으로, 블록 체인 응용 프로그램은 단순히 복제된 상태 머신입니다. 상태 (예: 암호화폐, 각 계정이 보유하는 동전 수) 및 상태 전이를 트리거하는 트랜잭션이 있습니다. 응용 프로그램 개발자는 상태, 트랜잭션 유형 및 다른 트랜잭션이 상태를 수정하는 방법을 정의합니다.

### 모듈성

Cosmos-SDK는 모듈 기반 프레임워크입니다. 각 모듈은 그 자체로 작은 상태 기계이며 다른 모듈과 쉽게 결합되어 일관된 응용 프로그램을 생성 할 수 있습니다. 즉, 모듈은 전역 상태와 트랜잭션 유형의 하위 섹션을 정의합니다. 그런 다음, 각 유형에 따라 올바른 모듈로 트랜잭션을 라우팅하는 것은 루트 응용 프로그램의 일입니다. 이 과정을 이해하기 위해 상태 머신의 단순화된 일반적인 주기를 살펴 보겠습니다.

Tendermint Core 엔진에서 트랜잭션을 수신하면, 다음은 *응용 프로그램*이 수행하는 작업입니다:

1. 트랜잭션을 디코드하고 메시지를 받음
2.`Msg.Type()` 메소드를 사용하여 메시지를 적절한 모듈로 라우팅
3. 모듈에서 트랜잭션을 실행. 트랜잭션이 유효하면 상태를 수정.
4. 새 상태 또는 오류 메시지를 반환

단계 1, 2 및 4는 루트 응용 프로그램에서 처리합니다. 3 단계는 해당 모듈에서 처리합니다.

### SDK 구성 요소

이를 염두에두고 SDK의 중요한 디렉토리를 살펴 보겠습니다:

-`baseapp`: 기본 응용 프로그램을위한 템플릿을 정의. 기본적으로 Cosmos-SDK 응용 프록로그램이 기본 Tendermint 노드와 통신 할 수 있도록 ABCI 프로토콜을 구현합니다.
-`client`: 응용 프로그램과 상호 작용하는 커맨드라인 인터페이스
-`server`: 노드와 통신하기 위한 REST 서버
-`examples`: `baseapp`과 모듈을 기반으로 작동하는 응용 프로그램을 만드는 법에 대한 예제가 들어 있음
-`store`: 멀티 스토어에 대한 코드를 포함. 멀티 스토어는 기본적으로 사용자의 상태입니다. 각 모듈은 멀티 스토어에서 원하는 수의 KVStore들을 생성 할 수 있습니다. 해당 `키퍼`를 사용하여 각 상점에 대한 액세스 권한을 올바르게 처리하도록 주의하십시오.
-`types`: SDK 기반의 모든 응용 프로그램에 필요한 공통 유형.
-`x`: 모듈이 있는 곳. 이 디렉토리에는 이미 빌드된 모듈이 모두 있습니다. 이러한 모듈 중 하나를 사용하려면, 응용 프로그램에서 적절하게 가져와야합니다. [App - 모든 것을 하나로 연결] 섹션에서 우리는 사용방법을 보게 될 것입니다.

### 입문자들을 위한 코드런

#### KV스토어

KV스토어는 SDK 응용 프로그램의 기본 지속성 계층을 제공합니다.

```go
type KVStore interface {
    Store

    // Get 키가 존재하지 않으면 nil을 반환합니다. nil 키면 패닉실행.
    Get(key []byte) []byte

    // Has 키가 있는지 검사합니다. nil 키면 패닉실행.
    Has(key []byte) bool

    // Set 키를 설정합니다. nil 키면 패닉실행.
    Set(key, value []byte)

    // Delete 키를 삭제합니다. nil 키면 패닉실행.
    Delete(key []byte)

    // 오름차순으로 키 도메인에 대한 반복자. End는 배타적임.
    // Start는 end보다 작아야합니다. 그렇지 않으면 iterator가 유효하지 않습니다.
    // CONTRACT: 반복자가 있는 동안은 도메인내에서 쓰기가 발생하지 않습니다.
    Iterator(start, end []byte) Iterator

    // 오름차순으로 키 도메인에 대한 반복자. End는 배타적임.
    // Start는 end보다 작아야합니다. 그렇지 않으면 iterator가 유효하지 않습니다.
    // CONTRACT: 반복자가 있는 동안은 도메인내에서 쓰기가 발생하지 않습니다.
    ReverseIterator(start, end []byte) Iterator

    // TODO 아직 구현되지 않았습니다.
    // CreateSubKVStore(key *storeKey) (KVStore, error)

    // TODO 아직 구현되지 않았습니다.
    // GetSubKVStore(key *storeKey) KVStore
 }
```

계정에 하나, IBC에 하나 등과 같이, 여러 개의 KVStore를 응용 프로그램에 마운트 할 수 있습니다.

```go
 app.MountStoresIAVL(app.keyMain, app.keyAccount, app.keyIBC, app.keyStake, app.keySlashing)
```

요청이있는 경우, KVStore의 구현은 각 쿼리에 대해 Merkle 증명을 제공 할 책임이 있습니다.

```go
 func (st *iavlStore) Query(req abci.RequestQuery) (res abci.ResponseQuery) {
```

KVStore는 지속성 레벨에서 트랜잭션을 제공 할 수 있도록 캐시래핑 될 수 있습니니다 (iterator에서도 잘 지원됩니다). 이 기능은 "AnteHandler"가 트랜잭션에 대한 모든 관련 비용을 공제 한 후 트랜잭션 처리를 위한 트랜잭션 격리 계층을 제공하는 데 사용됩니다. 캐시래핑은 블록 체인을위한 가상 머신 또는 스크립팅 환경을 구현할 때 유용 할 수 있습니다.

#### go-amino

Cosmos-SDK는 Go 형식을 Protobuf3 호환 바이트로 직렬화 및 비직렬화 하기 위해 [go-amino] (https://github.com/cosmos/cosmos-sdk/blob/96451b55fff107511a65bf930b81fb12bed133a1/examples/basecoin/app/app.go#L97-L111)를 광범위하게 사용합니다.

Go-amino (예 : https://github.com/golang/protobuf)는 리플렉션을 사용하여 Go 객체를 인코딩/디코딩합니다.  이를 통해 SDK 개발자는 Proto3에 대한 별도의 스키마를 유지할 필요없이 Go에서 데이터 구조를 정의하는데 집중할 수 있습니다. 또한, Amino는 인터페이스 및 실제 타입을 위해 네이티브 지원을 통해 Proto3을 확장합니다.

예를 들어, Cosmos-SDK의 `x/auth` 패키지는 PubKey 인터페이스를`tendermint/go-crypto` 에서 가져옵니다. PubKey 구현은 _Ed25519_ 및 _Secp256k1_에 대한 구현을 포함합니다.  각 `auth.BaseAccount`에는 PubKey가 있습니다.

```go
 // BaseAccount - 기본 계정 구조.
 // AppAccount에 이것을 포함시켜 확장합니다.
 // 예제를 보려면 examples/basecoin/types/account.go를 참조하십시오.
 type BaseAccount struct {
    Address  sdk.Address   `json:"address"`
    Coins    sdk.Coins     `json:"coins"`
    PubKey   crypto.PubKey `json:"public_key"`
    Sequence int64         `json:"sequence"`
 }
```

Amino는 인터페이스에 등록 된 실제 값을 기반으로 각 인터페이스 값에 대해 디코딩할 실제 타입을 알고 있습니다.

예를 들어, `Basecoin` 예제 애플리케이션은 _Ed25519_와 _Secp256k1_ 키에 대해 알고 있는데, 그 이유는 아래의 앱의 'codec'에 의해 등록 되었기 때문입니다.

```go
wire.RegisterCrypto(cdc) // 암호를 등록.
```

Go-Amino에 대한 자세한 내용은 https://github.com/tendermint/go-amino를 참조하십시오.

#### Keys, Keepers, 그리고 Mappers

Cosmos-SDK는 전체 응용 프로그램을 구성하기 위해 함께 포함될 수 있는 라이브러리의 생태계를 활성화할 수 있도록 설계되었습니다. 이 생태계를보다 안전하게 만들기 위해 최소-권한 원칙에 따라 디자인 패턴을 개발했습니다.

`Mappers`와 `Keepers`는 컨텍스트를 통해 KVStore 들에 대한 액세스를 제공합니다. 이 둘의 유일한 차이점은 `Mapper`가 낮은 수준의 API를 제공하기 때문에 일반적으로 `Keepr`는 다른 `Keepers` 및 `Mappers`에 대한 참조를 보유 할 수 있지만 그 반대는 아닙니다.

`Mappers`와 `Keepers`는 직접 KVStore들을 참조하지 않습니다.  그들은 오직 _key_ (아래의 `sdk.StoreKey`) 만을 가지고 있습니다:

```go
type AccountMapper struct {
    // 컨텍스트에서 KVStore에 액세스하는 데 사용된 (노출되지 않은) 키입니다.
    key sdk.StoreKey
    // 계정 실제 타입.
    proto Account
    // 계정의 바이너리 인코딩/디코딩을 위한 와이어 코덱.
    cdc *wire.Codec
 }
```

이런 식으로, 당신은 `app.go` 파일에 모든 것을 연결하고 어떤 컴포넌트가 어떤 KVStore 들과 다른 컴포넌트에 접근 할 수 있는지를 볼 수 있습니다.

```go
// accountMapper를 정의합니다.
 app.accountMapper = auth.NewAccountMapper(
    cdc,
    app.keyAccount, // 대상 KVStore
    &types.AppAccount{}, // prototype
 )
```

나중에 트랜잭션을 실행하는 동안 (예: 블록 커밋 후에 ABCI `DeliverTx`를 통해) 컨텍스트가 첫 번째 인수로 전달됩니다.  컨텍스트에는 모든 관련 KVStore 들에 대한 참조가 포함되지만 관련 키를 보유한 경우에만 액세스 할 수 있습니다.

```go
 // sdk.AccountMapper를 구현합니다.
 func (am AccountMapper) GetAccount(ctx sdk.Context, addr sdk.Address) Account {
    store := ctx.KVStore(am.key)
    bz := store.Get(addr)
    if bz == nil {
        return nil
    }
    acc := am.decodeAccount(bz)
    return acc
 }
```

`Mappers`와 `Keepers`는 앱 초기화시 KVStore가 알려지지 않아 KVStore에 대한 직접적인 참조를 가질 수 없습니다.  KVStore는 모든 커밋 된 트랜잭션 (ABCI `DeliverTx`를 통해) 및 메모리풀 확인 트랜잭션 (ABCI `CheckTx`를 통해)에 대해 동적으로 생성됩니다 (그리고 트랜잭션 컨텍스트를 제공하는 데 필요한대로 `CacheKVStore`를 통해 래핑됩니다).
